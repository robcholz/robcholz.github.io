<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>robcholz — Systems &amp; AI Engineering Blog</title>
  
  <subtitle>Embedded Systems • Rust • ESP32 • AI-Driven Development</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.robcholz.com/"/>
  <updated>2026-01-09T14:54:47.011Z</updated>
  <id>https://www.robcholz.com/</id>
  
  <author>
    <name>robcholz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Project]  Lumen</title>
    <link href="https://www.robcholz.com/2026/01/02/lumen/"/>
    <id>https://www.robcholz.com/2026/01/02/lumen/</id>
    <published>2026-01-02T11:25:39.907Z</published>
    <updated>2026-01-09T14:54:47.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lumen"><a href="#Lumen" class="headerlink" title="Lumen"></a>Lumen</h1><p align="middle">  <img src="/2026/01/02/lumen/cover.jpeg" style="width:500px" alt="cover"></p><h2 id="1-Motivation-Forcing-System-State-Onto-the-Desk"><a href="#1-Motivation-Forcing-System-State-Onto-the-Desk" class="headerlink" title="1. Motivation: Forcing System State Onto the Desk"></a>1. Motivation: Forcing System State Onto the Desk</h2><p>Lumen started from a simple failure mode: system and application state stayed trapped behind windows and logs. Nothing<br>on the desk moved, blinked, or sounded different when builds broke, power spiked, or motion changed. The workspace<br>stayed visually flat even when the machine was on fire.</p><p>The goal for Lumen was to clamp on that gap and build a <strong>desk-first, programmable hardware presence</strong>:</p><ul><li>Link software and system state to <strong>physical feedback</strong>: lights, motion, sound, display.</li><li>Keep the device useful even when the host PC is detached.</li><li>Avoid custom programmers and opaque tools so users don’t get blocked before the first boot.</li></ul><p>That forced three constraints:</p><ol><li><p><strong>Fully open source, firmware-level programmable.</strong><br>No “vendor firmware” blob that can’t be rebuilt.</p></li><li><p><strong>Straightforward build and flash flow.</strong><br>A user with a browser should be able to flash CI-produced binaries through WebUSB without installing a toolchain.</p></li><li><p><strong>Long-term desktop value over peak performance.</strong><br>If a small performance win broke reproducibility or required special jigs, it got dropped.</p></li></ol><p>These constraints shaped everything: the stack, the drivers, and how the CI pipeline was wired.</p><hr><h2 id="2-Project-Framework-Design"><a href="#2-Project-Framework-Design" class="headerlink" title="2. Project Framework Design"></a>2. Project Framework Design</h2><h3 id="2-1-Hardware-Platform-and-System-Layout"><a href="#2-1-Hardware-Platform-and-System-Layout" class="headerlink" title="2.1 Hardware Platform and System Layout"></a>2.1 Hardware Platform and System Layout</h3><p>The hardware (v2) locks in the capabilities and therefore the firmware structure:</p><ul><li><strong>MCU:</strong> ESP32‑C3</li><li><strong>Sensors and IO:</strong><ul><li>LSM6DSO IMU</li><li>INA226 current sensor</li><li>Buzzer</li><li>Rotary encoder</li></ul></li><li><strong>Display:</strong><ul><li>240×240 panel, ST7789‑like, driven via <code>esp_lcd</code></li></ul></li><li><strong>Power and connectivity:</strong><ul><li>USB‑C</li><li>Power switch</li></ul></li></ul><p>This stack forced a design where display throughput, motion sampling, power monitoring, and host I/O all run<br>concurrently without clobbering each other, under <strong>FreeRTOS</strong>.</p><h3 id="2-2-Firmware-Stack-FreeRTOS-Core-Layered-Drivers"><a href="#2-2-Firmware-Stack-FreeRTOS-Core-Layered-Drivers" class="headerlink" title="2.2 Firmware Stack: FreeRTOS Core, Layered Drivers"></a>2.2 Firmware Stack: FreeRTOS Core, Layered Drivers</h3><p>At the firmware level, Lumen runs on <strong>ESP‑IDF v5.5</strong> with FreeRTOS. The project is structured in layers rather than one<br>monolithic <code>main.c</code>:</p><ol><li><p><strong>Hardware drivers (C/C++):</strong></p><ul><li>Display panel via <code>esp_lcd</code></li><li>I2C plumbing for LSM6DSO and INA226</li><li>Rotary encoder and buzzer</li><li>USB serial‑JTAG interface</li></ul></li><li><p><strong>System integration and logic:</strong></p><ul><li>FreeRTOS task graph</li><li>Motion task</li><li>UI rendering pipeline</li><li>Host serial protocol</li></ul></li><li><p><strong>Rust no‑std component (main_app):</strong></p><ul><li>Sits only in the <strong>system integration layer</strong>.</li><li>Does <em>not</em> replace the C/C++ hardware drivers.</li><li>Avoids a split stack where half the drivers live in one language and half in another.</li></ul></li></ol><p>Rust was pulled in specifically where it helped structure higher‑level integration logic, not to rewrite vendor SDK<br>surfaces. That constraint prevented a steady stream of build and tooling failures from dual ecosystems fighting each<br>other.</p><h3 id="2-3-UI-Stack-Vision‑UI-on-u8g2-on-ST7789"><a href="#2-3-UI-Stack-Vision‑UI-on-u8g2-on-ST7789" class="headerlink" title="2.3 UI Stack: Vision‑UI on u8g2 on ST7789"></a>2.3 UI Stack: Vision‑UI on u8g2 on ST7789</h3><p>The display stack uses a layered approach to keep UI changes from breaking lower layers:</p><ul><li><strong>Vision‑UI</strong>: a small embedded UI library.</li><li><strong>u8g2</strong>: provides a <strong>mono framebuffer</strong> and drawing primitives.</li><li><strong>Panel driver</strong>: ST7789‑like display, driven via <code>esp_lcd</code> APIs.</li></ul><p>Implementation lives in <code>main/src/ui_hardware_driver.cpp</code>:</p><ul><li>A global <code>PANEL</code> handle ties into <code>esp_lcd</code>.</li><li>The UI code only sees a framebuffer and a driver callback to “send buffer,” not the exact panel timing.</li></ul><p>This wiring means:</p><ul><li>UI layout changes do not force display driver changes.</li><li>Display driver swaps stay local to the <code>esp_lcd</code> layer.</li><li>The top‑level logic doesn’t need to know about DMA allocations or RGB565 conversions.</li></ul><h3 id="2-4-Build-and-Release-CI‑First-Web-Flash-Second"><a href="#2-4-Build-and-Release-CI‑First-Web-Flash-Second" class="headerlink" title="2.4 Build and Release: CI‑First, Web Flash Second"></a>2.4 Build and Release: CI‑First, Web Flash Second</h3><p>The build system is pinned down in <code>.github/workflows/build.yml</code>:</p><ul><li><strong>GitHub Actions</strong> installs:<ul><li>ESP‑IDF v5.5</li><li>A minimal Rust toolchain</li><li>The RISC‑V target for ESP32‑C3</li></ul></li><li>CI runs <code>idf.py build</code> and produces <strong>firmware artifacts</strong>.</li></ul><p>Those artifacts feed a <strong>web flashing flow</strong>:</p><ul><li>Browser + WebUSB grabs the CI artifact and flashes the board.</li><li>No local ESP‑IDF or Rust installation is required for basic users.</li></ul><p>This flow looked heavier than a one‑off local build, but it removed a constant failure mode: users blocked by toolchain<br>setup. All complexity is clamped into CI instead of onto every developer’s machine.</p><hr><h2 id="3-Overhead-Balance-and-Tradeoffs"><a href="#3-Overhead-Balance-and-Tradeoffs" class="headerlink" title="3. Overhead Balance and Tradeoffs"></a>3. Overhead Balance and Tradeoffs</h2><h3 id="3-1-Reproducibility-vs-Performance"><a href="#3-1-Reproducibility-vs-Performance" class="headerlink" title="3.1 Reproducibility vs. Performance"></a>3.1 Reproducibility vs. Performance</h3><p>Several design choices pulled away from “fastest possible” and toward “reproducible and survivable”:</p><ul><li><p>Using <strong>ESP‑IDF v5.5</strong> and <code>esp_lcd</code> adds abstraction and some overhead vs. hand‑tuned register banging, but:</p><ul><li>It keeps code aligned with upstream.</li><li>It avoids a fragile, undocumented display driver that breaks when the next board spin rearranges pins.</li></ul></li><li><p>Driving the display through a <strong>u8g2 mono framebuffer</strong> and then converting to RGB565 is not the fastest route:</p><ul><li>A direct color framebuffer could shave steps.</li><li>But it would lock UI code into a specific panel format.</li><li>The chosen route makes assets and widgets less brittle when the panel or bus changes.</li></ul></li></ul><p>The README explicitly notes that squeezing the last bit of performance did not win over long‑term desktop usefulness and<br>reproducibility.</p><h3 id="3-2-Independence-from-the-Host-PC"><a href="#3-2-Independence-from-the-Host-PC" class="headerlink" title="3.2 Independence from the Host PC"></a>3.2 Independence from the Host PC</h3><p>Another hard constraint: the device must hold value even when unplugged from any PC.</p><p>Two consequences:</p><ul><li><p><strong>Core logic cannot depend on serial I/O:</strong></p><ul><li>The <strong>serial pack</strong> protocol (host interaction) is optional.</li><li>Motion processing, display updates, and protection logic run without any host.</li></ul></li><li><p><strong>UI decoupled from top‑level logic:</strong></p><ul><li>Input handling and UI rendering can change without rewriting the control loop.</li><li>Firmware doesn’t stall if the serial channel drops or a host app misbehaves.</li></ul></li></ul><p>This avoids a failure mode where an absent or crashed host application bricks device usefulness.</p><h3 id="3-3-Web-Flashing-Limitations"><a href="#3-3-Web-Flashing-Limitations" class="headerlink" title="3.3 Web Flashing Limitations"></a>3.3 Web Flashing Limitations</h3><p>The web flashing path trades one class of problems for another:</p><ul><li><p><strong>Dependency on WebUSB support:</strong></p><ul><li>Some browsers and platforms simply do not support it.</li><li>In those cases, the user is forced back to local tooling.</li></ul></li><li><p><strong>No CI caching yet:</strong></p><ul><li>The current CI build workflow does not cache IDF or build artifacts.</li><li>Every build re‑does configuration and compilation.</li><li>Builds therefore take longer than necessary.</li></ul></li></ul><p>The README calls these out instead of hiding them. Build times can be improved later by inserting caching or diff<br>builds, but correctness and repeatability were prioritized first.</p><hr><h2 id="4-Display-Pipeline-Double‑Buffered-DMA-Under-Pressure"><a href="#4-Display-Pipeline-Double‑Buffered-DMA-Under-Pressure" class="headerlink" title="4. Display Pipeline: Double‑Buffered DMA Under Pressure"></a>4. Display Pipeline: Double‑Buffered DMA Under Pressure</h2><h3 id="4-1-Design-Constraint"><a href="#4-1-Design-Constraint" class="headerlink" title="4.1 Design Constraint"></a>4.1 Design Constraint</h3><p>The display needed to refresh a 240×240 panel without stalling the MCU or blocking other tasks. Direct full‑frame copies<br>would overflow time budgets and starve motion and serial tasks.</p><p>To avoid that, the implementation uses <strong>line‑based double buffering</strong> with DMA‑capable memory:</p><ul><li>Defined in <code>main/src/ui_hardware_driver.cpp</code>.</li><li>Globals and constants:<ul><li><code>S_LINES[2]</code>: two DMA‑capable line buffers.</li><li><code>S_BUF_BUSY[2]</code>: flags to track which buffer is in-flight.</li><li><code>PARALLEL_LINES</code>: number of lines per chunk; set to 128.</li><li><code>PANEL</code>: <code>esp_lcd_panel_handle_t</code>.</li></ul></li></ul><h3 id="4-2-Pipeline-Behavior"><a href="#4-2-Pipeline-Behavior" class="headerlink" title="4.2 Pipeline Behavior"></a>4.2 Pipeline Behavior</h3><ol><li><p><strong>Initialization (<code>displayInit</code>):</strong></p><ul><li>Allocates <code>S_LINES[0]</code> and <code>S_LINES[1]</code> with <code>heap_caps_malloc</code> using <code>MALLOC_CAP_DMA | MALLOC_CAP_INTERNAL</code>.</li><li>Sets up the panel via <code>esp_lcd</code>, including a callback:<ul><li><code>onColorTransDone</code>: fires when DMA completes for a chunk.</li></ul></li></ul></li><li><p><strong>Rendering (<code>vision_ui_driver_buffer_send</code>):</strong></p><ul><li>UI code provides a mono u8g2 framebuffer.</li><li>The driver:<ul><li>Splits it into RGB565 blocks of <code>PARALLEL_LINES</code> height.</li><li>For each block:<ul><li>Finds a <strong>non‑busy</strong> buffer (<code>S_BUF_BUSY[i] == false</code>).</li><li>Converts mono data into RGB565 into that buffer.</li><li>Calls <code>esp_lcd_panel_draw_bitmap</code> on <code>PANEL</code> for that chunk.</li><li>Marks buffer busy.</li></ul></li></ul></li></ul></li><li><p><strong>DMA completion (<code>onColorTransDone</code>):</strong></p><ul><li>Clears the corresponding <code>S_BUF_BUSY[i]</code>.</li><li>Signals that chunk buffer is ready to be reused.</li></ul></li></ol><p>This design keeps the CPU from sitting on long blocking writes. Conversion and DMA transfer are overlapped: while one<br>buffer is in flight, the other can be filled.</p><h3 id="4-3-Tradeoffs"><a href="#4-3-Tradeoffs" class="headerlink" title="4.3 Tradeoffs"></a>4.3 Tradeoffs</h3><ul><li><p><strong>Pros:</strong></p><ul><li>Reduced stalls on the display path.</li><li>Predictable memory footprint via <code>PARALLEL_LINES</code> control.</li><li>Easier tuning for future panels.</li></ul></li><li><p><strong>Cons:</strong></p><ul><li>Extra copy step: mono → RGB565.</li><li>More state to track (<code>S_BUF_BUSY</code>, callbacks).</li><li>Harder debugging when transfers misalign.</li></ul></li></ul><p>The double‑buffering logic is deliberately localized in <code>ui_hardware_driver.cpp</code> so that higher layers don’t need to<br>know about DMA or panel quirks.</p><hr><h2 id="5-Motion-Processing-IMU-Task-and-Filters"><a href="#5-Motion-Processing-IMU-Task-and-Filters" class="headerlink" title="5. Motion Processing: IMU Task and Filters"></a>5. Motion Processing: IMU Task and Filters</h2><h3 id="5-1-Motion-Task-Setup"><a href="#5-1-Motion-Task-Setup" class="headerlink" title="5.1 Motion Task Setup"></a>5.1 Motion Task Setup</h3><p>Motion handling sits in its own FreeRTOS task to avoid blocking UI or serial operations.</p><p>Implementation: <code>main/src/motion.cpp</code>.</p><p>Key pieces:</p><ul><li><strong>IMU:</strong> LSM6DSO</li><li><strong>I2C access:</strong> shared handle, with wrappers:<ul><li><code>imuWrite</code></li><li><code>imuRead</code></li><li><code>imuWriteThenRead</code></li></ul></li><li><strong>Task:</strong><ul><li><code>motionInit</code> sets up IMU and spawns <code>motionTask</code> with <code>xTaskCreate</code>.</li><li>Target rate: roughly <strong>25 Hz</strong>.</li></ul></li></ul><h3 id="5-2-Orientation-Estimation"><a href="#5-2-Orientation-Estimation" class="headerlink" title="5.2 Orientation Estimation"></a>5.2 Orientation Estimation</h3><p>Two filter paths run on the sensor data:</p><ol><li><p><strong>2‑state Kalman filter (<code>espp::KalmanFilter&lt;2&gt;</code>, <code>S_KF</code>):</strong></p><ul><li>Tracks roll and pitch.</li><li>Smooths noisy accel/gyro inputs.</li></ul></li><li><p><strong>Madgwick filter (<code>MADGWICK</code>):</strong></p><ul><li>Provides full orientation (quaternion).</li><li>Fuses accelerometer and gyroscope data.</li></ul></li></ol><h3 id="5-3-Mounting-Fix-and-Accel-Scaling"><a href="#5-3-Mounting-Fix-and-Accel-Scaling" class="headerlink" title="5.3 Mounting Fix and Accel Scaling"></a>5.3 Mounting Fix and Accel Scaling</h3><p>The physical mounting ended up upside‑down relative to the IMU’s default orientation. That broke orientation output<br>early on. The fix:</p><ul><li><strong>Axis flip:</strong><ul><li>Y and Z axes are flipped.</li><li>Gyro axes are also flipped accordingly.</li></ul></li></ul><p>Without this correction, roll/pitch estimates were mirrored and drifted in unexpected ways.</p><p>To keep the acceleration magnitude sane:</p><ul><li><strong>Adaptive accel scaling</strong>:<ul><li>Normalizes magnitude to approximately <strong>9.80665 m/s²</strong>.</li><li>Prevents gravity from drifting away due to calibration offsets.</li></ul></li></ul><p>This scaling avoids overflow in the filters and reduces long‑term drift.</p><h3 id="5-4-Runtime-Behavior"><a href="#5-4-Runtime-Behavior" class="headerlink" title="5.4 Runtime Behavior"></a>5.4 Runtime Behavior</h3><p>The motion task:</p><ul><li>Samples the IMU at ~25 Hz.</li><li>Runs the Kalman and Madgwick updates.</li><li>Exposes motion/pose data internally (and via host protocol).</li></ul><p>By isolating this in one task, any stalls in host communication or display updates do not directly block sensor reads.<br>If CPU load increases, sampling may drop somewhat, but the rest of the system keeps running.</p><hr><h2 id="6-Serial-“Pack”-Protocol-Host-Integration-Without-Entanglement"><a href="#6-Serial-“Pack”-Protocol-Host-Integration-Without-Entanglement" class="headerlink" title="6. Serial “Pack” Protocol: Host Integration Without Entanglement"></a>6. Serial “Pack” Protocol: Host Integration Without Entanglement</h2><h3 id="6-1-Requirements"><a href="#6-1-Requirements" class="headerlink" title="6.1 Requirements"></a>6.1 Requirements</h3><p>Host connectivity needed to:</p><ul><li>Support structured commands and payloads.</li><li>Avoid a tangled binary protocol that blocks easy debugging.</li><li>Stay <strong>optional</strong>: no hard dependency for core firmware behavior.</li></ul><h3 id="6-2-Protocol-Structure"><a href="#6-2-Protocol-Structure" class="headerlink" title="6.2 Protocol Structure"></a>6.2 Protocol Structure</h3><p>The <strong>serial pack</strong> protocol lives in <code>main/src/serial_pack.cpp</code> and runs over the <strong>USB serial‑JTAG</strong> interface.</p><p>Basic flow for each message:</p><ol><li><p><strong>Path:</strong></p><ul><li>ASCII string.</li><li>Terminated by newline (<code>\n</code>).</li><li>Example: <code>motion/data\n</code>.</li></ul></li><li><p><strong>Length:</strong></p><ul><li>4‑byte little‑endian integer.</li><li>Specifies payload size.</li></ul></li><li><p><strong>Payload:</strong></p><ul><li>Binary blob of that length.</li></ul></li></ol><p>A handler table routes messages based on the path.</p><h3 id="6-3-Implementation-Details"><a href="#6-3-Implementation-Details" class="headerlink" title="6.3 Implementation Details"></a>6.3 Implementation Details</h3><p>Constants:</p><ul><li><code>K_MAX_HANDLERS = 2</code><br>Small fixed table; keeps memory fixed and simple.</li><li><code>K_MAX_DATA_LEN = 2048</code><br>Hard clamp to prevent payloads from blowing up buffers.</li><li><code>K_RX_TIMEOUT_US = 3 * 1000 * 1000</code><br>3‑second receive timeout.</li></ul><p>Main functions:</p><ul><li><p><code>serialPackInit</code><br>Sets up state.</p></li><li><p><code>serialPackAttachHandler</code><br>Registers handler callbacks:</p><ul><li>Up to <code>K_MAX_HANDLERS</code>.</li><li>Each handler keyed by path string.</li></ul></li><li><p><code>serialPackStart</code> / <code>serialPackTask</code><br>Runs the read loop:</p><ul><li>Reads the path until newline.</li><li>Parses the 4‑byte length.</li><li>If <code>length &gt; K_MAX_DATA_LEN</code>, the message is effectively rejected.</li><li>Reads the payload in <strong>chunks</strong>:<ul><li>Dispatches chunks incrementally to handlers.</li><li>Applies timeout via <code>K_RX_TIMEOUT_US</code>.</li></ul></li><li>Optional logging/preview to help debugging.</li></ul></li></ul><h3 id="6-4-Tradeoffs-and-Failure-Modes"><a href="#6-4-Tradeoffs-and-Failure-Modes" class="headerlink" title="6.4 Tradeoffs and Failure Modes"></a>6.4 Tradeoffs and Failure Modes</h3><ul><li><p><strong>Low handler count (<code>K_MAX_HANDLERS = 2</code>):</strong></p><ul><li>Forces consolidation of endpoints.</li><li>Prevents unbounded growth of handler registrations.</li></ul></li><li><p><strong>Payload clamp (<code>K_MAX_DATA_LEN = 2048</code>):</strong></p><ul><li>Protects against memory blow‑ups if a host goes rogue.</li><li>Blocks large streaming use cases unless the protocol is extended.</li></ul></li><li><p><strong>Timeout (<code>K_RX_TIMEOUT_US = 3s</code>):</strong></p><ul><li>Prevents the parser from hanging forever on partial messages.</li><li>Under poor USB conditions, packets might get dropped or truncated when the timeout triggers.</li></ul></li></ul><p>By keeping the protocol text‑framed on the path and length‑delimited on the payload, debugging is still manageable with<br>simple serial tools.</p><hr><h2 id="7-Features-and-Observed-Results"><a href="#7-Features-and-Observed-Results" class="headerlink" title="7. Features and Observed Results"></a>7. Features and Observed Results</h2><h3 id="7-1-Hardware-Feature-Set-v2"><a href="#7-1-Hardware-Feature-Set-v2" class="headerlink" title="7.1 Hardware Feature Set (v2)"></a>7.1 Hardware Feature Set (v2)</h3><p>From the README and hardware directory, v2 boards include:</p><ul><li><strong>Display:</strong> 240×240 ST7789‑like panel.</li><li><strong>Motion:</strong> LSM6DSO IMU.</li><li><strong>Power:</strong> INA226 current sensor on USB‑C path.</li><li><strong>Interaction:</strong><ul><li>Rotary encoder.</li><li>Buzzer.</li></ul></li><li><strong>Power control:</strong> physical power switch.</li></ul><p>This combination gives enough axes—visual, motion, and sound—to map varied system state into desk‑visible behavior.</p><h3 id="7-2-Implemented-Firmware-Capabilities"><a href="#7-2-Implemented-Firmware-Capabilities" class="headerlink" title="7.2 Implemented Firmware Capabilities"></a>7.2 Implemented Firmware Capabilities</h3><p>Firmware features visible in the repository:</p><ul><li><p><strong>USB‑C power monitoring and protection:</strong></p><ul><li>INA226 sensor used for current/voltage measurements.</li><li>Protection logic clamps down on unsafe conditions (details wired into the system logic).</li></ul></li><li><p><strong>Motion tracking:</strong></p><ul><li>IMU readout with Kalman and Madgwick filters.</li><li>Mounting fix applied for orientation correctness.</li></ul></li><li><p><strong>UI rendering via Vision‑UI:</strong></p><ul><li>Framebuffer driven UI.</li><li>Display assets embedded in firmware:<ul><li><code>ui_assets_provider.cpp</code> provides embedded images/fonts for Vision‑UI.</li></ul></li></ul></li><li><p><strong>Host communication:</strong></p><ul><li>Serial pack protocol over USB serial‑JTAG.</li><li>Structured path + length framing.</li></ul></li><li><p><strong>Web quick flashing:</strong></p><ul><li>CI‑produced artifacts used directly by the web flasher.</li><li>No local toolchain needed for basic flashing.</li></ul></li></ul><h3 id="7-3-Runtime-Behavior-and-Observations"><a href="#7-3-Runtime-Behavior-and-Observations" class="headerlink" title="7.3 Runtime Behavior and Observations"></a>7.3 Runtime Behavior and Observations</h3><p>In combined operation, the system:</p><ul><li>Refreshes the 240×240 panel with double‑buffered DMA without starving FreeRTOS tasks.</li><li>Samples motion at ~25 Hz while filtering orientation in real time.</li><li>Streams motion and state over the serial pack protocol when a host is present.</li><li>Continues to function (UI, motion, basic behavior) without any serial host connected.</li></ul><p>Overhead is clearly present: layered UI, filters, serial protocol, CI scaffolding. But each layer was added in response<br>to a concrete failure mode—tooling blockage, display stalls, incorrect orientation, unsafe power behavior—rather than as<br>abstract design.</p><p>Lumen ends up as a reproducible, firmware‑level programmable desk companion that ties system state into light, motion,<br>and sound without depending on a constant host tether.</p>]]></content>
    
    <summary type="html">
    
      A build log of Lumen, a desk-first hardware presence tying system state to motion, light, and sound through an ESP32-C3 firmware framework.
    
    </summary>
    
    
      <category term="ece" scheme="https://www.robcholz.com/tags/ece/"/>
    
      <category term="software" scheme="https://www.robcholz.com/tags/software/"/>
    
      <category term="proj" scheme="https://www.robcholz.com/tags/proj/"/>
    
  </entry>
  
  <entry>
    <title>[Project]  Vision-UI</title>
    <link href="https://www.robcholz.com/2025/11/16/vision-ui/"/>
    <id>https://www.robcholz.com/2025/11/16/vision-ui/</id>
    <published>2025-11-16T19:02:00.000Z</published>
    <updated>2026-01-09T14:54:47.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vision-UI"><a href="#Vision-UI" class="headerlink" title="Vision-UI"></a>Vision-UI</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>On most small embedded displays I’ve worked with, the hardware is fast enough, but the motion still doesn’t feel right.<br>Animations often look choppy or patched together.</p><p>I wanted to see whether a basic MCU — for example, an STM32F1 driving a 128×64 display — could produce motion that feels<br>more natural while staying lightweight enough for small devices.</p><p>This eventually became Vision UI.<br>But the goal wasn’t to “build a UI framework.”<br>It was mainly an attempt to understand what makes smooth motion and consistent visual behavior possible on tiny<br>hardware.</p><p>On small devices, smoothness doesn’t come for free.<br>Every animation curve, frame, and pixel shift has to contend with timing jitter, limited RAM, SPI bandwidth, and a<br>strict per-frame time budget. Vision UI is just the structure that formed while working through those constraints.</p><h2 id="Positioning"><a href="#Positioning" class="headerlink" title="Positioning"></a>Positioning</h2><h3 id="Where-Vision-UI-sits-among-existing-embedded-UI-options"><a href="#Where-Vision-UI-sits-among-existing-embedded-UI-options" class="headerlink" title="Where Vision UI sits among existing embedded UI options"></a>Where Vision UI sits among existing embedded UI options</h3><table><thead><tr><th>Dimension</th><th>Vision UI</th><th>u8g2 + manual</th><th>LVGL</th></tr></thead><tbody><tr><td>Displays</td><td>Small mono/TFT</td><td>Mono/basic TFT</td><td>Color + touch</td></tr><tr><td>Goal</td><td>Smooth motion</td><td>Minimal draw logic</td><td>Full GUI stack</td></tr><tr><td>Abstraction</td><td>Medium</td><td>Low</td><td>High</td></tr><tr><td>Animation</td><td>2nd-order ODE</td><td>None/ad-hoc</td><td>Built-in</td></tr><tr><td>Memory</td><td>Low, predictable</td><td>Very low</td><td>High</td></tr><tr><td>Widgets</td><td>Lists/icons</td><td>Custom</td><td>Rich</td></tr><tr><td>Code growth</td><td>Centralized</td><td>Scattered</td><td>Centralized/config-heavy</td></tr><tr><td>Portability</td><td>HAL + PC sim</td><td>Project-specific</td><td>Ecosystem</td></tr><tr><td>Learning curve</td><td>Medium</td><td>Low</td><td>High</td></tr><tr><td>Best for</td><td>Small smooth UIs</td><td>Simple menus</td><td>Complex HMI</td></tr></tbody></table><blockquote><p><strong>Note</strong><br>Vision UI fills a specific gap between “handwritten drawing code” and “full GUI stacks”:</p></blockquote><ul><li>If you only need a couple of static menus, handwritten u8g2 code is often enough.</li><li>For complex touch interfaces, LVGL is the obvious choice.</li><li>Vision UI lives in between: small OLED/TFT screens that mainly show lists or simple layouts, but still benefit from<br>consistent, smooth motion, and swift development.</li></ul><h2 id="System-Design"><a href="#System-Design" class="headerlink" title="System Design"></a>System Design</h2><p>The constraints that shaped the design were straightforward:</p><ul><li>~64 KB usable RAM</li><li>128×64 / 240×240 displays with partial/full buffers</li><li>SPI/I2C bandwidth ceilings</li><li>Unstable tick timing on MCU boards</li><li>~3–4 ms per frame</li><li>Font rendering cost and limited caching</li></ul><p align="middle">  <img src="/2025/11/16/vision-ui/system-diagram.svg" style="width:500px" alt="system diagram"></p><p>The constraints drove most of the decisions.<br>The framework grew as I worked through the hardware limits, rather than from a big upfront design.</p><h2 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h2><p>Easing curves often look fine on isolated transitions, but they fall apart once you interrupt them.<br>Velocity doesn’t carry over, motions don’t combine well, and the transitions feel arbitrary.</p><p>A second-order ODE works better in this environment:</p><ul><li>continuous velocity</li><li>natural-looking acceleration</li><li>smooth interruption behavior</li><li>single-parameter responsiveness</li><li>intuitive to tune</li></ul><div style="  display: flex;  flex-wrap: wrap;  justify-content: space-between;  align-items: flex-start;  gap: 16px;">  <div style="flex:1 1 300px; text-align:center;">    <img src="/2025/11/16/vision-ui/noshoot.gif" style="width:300px; max-width:100%;" alt="Critically damped">    <div style="margin-top:6px; font-size:14px; color:#666;">      Critically damped (no overshoot)    </div>  </div>  <div style="flex:1 1 300px; text-align:center;">    <img src="/2025/11/16/vision-ui/overshoot.gif" style="width:300px; max-width:100%;" alt="Underdamped">    <div style="margin-top:6px; font-size:14px; color:#666;">      Lightly under-damped (with overshoot)    </div>  </div></div><p>Interrupting animations and handling unstable dt required a few fixes (clamping, integration limits, etc.), but once<br>stable, the ODE motion system made the rest of the UI logic much simpler.</p><div style="  display: flex;  flex-wrap: wrap;  justify-content: space-between;  align-items: flex-start;  gap: 16px;">  <!-- No Overshoot -->  <div style="flex:1 1 300px; text-align:center;">    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">      <iframe src="https://www.youtube.com/embed/walgS82d-6o" title="No Overshoot Demo" frameborder="0" allowfullscreen style="position: absolute; top:0; left:0; width:100%; height:100%;">      </iframe>    </div>    <div style="margin-top:6px; font-size:14px; color:#666;">No-overshoot demo</div>  </div>  <!-- With Overshoot -->  <div style="flex:1 1 300px; text-align:center;">    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">      <iframe src="https://www.youtube.com/embed/Xgssg0TlVl0" title="Overshoot Demo" frameborder="0" allowfullscreen style="position: absolute; top:0; left:0; width:100%; height:100%;">      </iframe>    </div>    <div style="margin-top:6px; font-size:14px; color:#666;">Light overshoot demo</div>  </div></div><h2 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h2><p>A few issues took more time than expected:</p><ul><li>Keeping animation stable under variable frame times</li><li>Making the motion system interrupt-friendly without breaking state</li><li>Tuning motion parameters for responsiveness without losing natural behavior</li><li>Keeping layout and animation logic consistent across driver backends</li><li>Balancing smooth motion against a tight per-frame time budget</li></ul><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>On a 240x240 OLED, Vision UI reaches around 220 FPS with the motion system active.<br>CPU usage stays under ~30% in my tests (at a fixed 80 FPS).</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Working on this made me realize how little room small systems give you.<br>You end up keeping only what’s necessary.</p><p>If I were starting over, I’d probably build the motion system first, since it influences most of the other pieces.</p><p>I’m already using Vision UI in a few side projects, and I’ll keep adjusting it as new use cases show up.</p><blockquote><p><strong>Tip</strong><br>I’ll keep adding details as the project moves forward.<br>If you’d like to follow along, you can find my Reddit and YouTube links under <code>Relevant Links</code> in the left menu.</p></blockquote>]]></content>
    
    <summary type="html">
    
      A brief write-up on the architecture and decisions behind Vision UI.
    
    </summary>
    
    
      <category term="proj" scheme="https://www.robcholz.com/tags/proj/"/>
    
  </entry>
  
  <entry>
    <title>[Foundation] Applied Electronics</title>
    <link href="https://www.robcholz.com/2025/09/29/applied-electronics/"/>
    <id>https://www.robcholz.com/2025/09/29/applied-electronics/</id>
    <published>2025-09-29T01:13:00.000Z</published>
    <updated>2026-01-09T14:54:46.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Foundation-Applied-Electronics"><a href="#Foundation-Applied-Electronics" class="headerlink" title="[Foundation] Applied Electronics"></a>[Foundation] Applied Electronics</h1><h2 id="1-Resistor"><a href="#1-Resistor" class="headerlink" title="1. Resistor"></a>1. Resistor</h2><h3 id="1-1-Voltage-Division"><a href="#1-1-Voltage-Division" class="headerlink" title="1.1 Voltage Division"></a>1.1 Voltage Division</h3><p>Resistors can be connected in series to divide voltage, commonly used for ADC inputs or op-amp biasing.</p><ul><li>Consider the <strong>resistance ratio</strong> and <strong>ADC resolution</strong> when designing a divider.</li><li>If <strong>low quiescent current</strong> is required, the divider’s output impedance increases, which affects accuracy:<ul><li>The ADC’s internal sampling capacitor may not fully charge.</li><li>The measured voltage may have error due to the <strong>RC time constant</strong>.</li></ul></li><li>When measuring <strong>high currents</strong>, use a <strong>high-power resistor</strong> to handle heat dissipation.</li></ul><hr><h3 id="1-2-Current-Limiting"><a href="#1-2-Current-Limiting" class="headerlink" title="1.2 Current Limiting"></a>1.2 Current Limiting</h3><p>Used to limit current to safe levels.</p><ul><li>Typical use cases: LED current control, MOSFET gate protection, transistor base drive.</li></ul><hr><h3 id="1-3-Pull-Up-Pull-Down"><a href="#1-3-Pull-Up-Pull-Down" class="headerlink" title="1.3 Pull-Up / Pull-Down"></a>1.3 Pull-Up / Pull-Down</h3><p>Used to define a stable logic level on floating pins (e.g., MCU inputs, I²C lines).</p><ul><li>Provides source current for <strong>open-drain/open-collector</strong> circuits.</li><li>Typical resistance ranges:<ul><li><strong>I²C:</strong> 2.2k–400kΩ (commonly 4.7k–10kΩ)</li><li><strong>MCU GPIO:</strong> ~10kΩ</li></ul></li><li>When low-power operation is critical, choose higher resistance to reduce <strong>quiescent current</strong>.</li></ul><hr><h3 id="1-4-Stabilization-Damping"><a href="#1-4-Stabilization-Damping" class="headerlink" title="1.4 Stabilization / Damping"></a>1.4 Stabilization / Damping</h3><p>Used to isolate and stabilize signal lines.</p><ul><li>Known as <strong>isolation resistors</strong> or <strong>damping resistors</strong>.</li><li>Reduces ringing, EMI, and cross-coupling on high-speed or sensitive traces.</li></ul><hr><h2 id="2-Capacitor"><a href="#2-Capacitor" class="headerlink" title="2. Capacitor"></a>2. Capacitor</h2><h3 id="2-1-Filtering-Decoupling"><a href="#2-1-Filtering-Decoupling" class="headerlink" title="2.1 Filtering / Decoupling"></a>2.1 Filtering / Decoupling</h3><p>Used to smooth voltage and suppress high-frequency noise.</p><ul><li>Place <strong>as close as possible</strong> to IC power pins.</li><li>Typical range: <strong>0.01 µF – 100 µF</strong>.</li><li>Pay attention to <strong>ESR</strong> (Equivalent Series Resistance) and <strong>stability</strong>.</li></ul><hr><h3 id="2-2-Timing-Oscillator"><a href="#2-2-Timing-Oscillator" class="headerlink" title="2.2 Timing / Oscillator"></a>2.2 Timing / Oscillator</h3><p>Used in RC or LC timing and oscillator circuits.</p><ul><li>Time constant: <strong>τ = R × C</strong></li><li>Consider <strong>tolerance</strong>, <strong>temperature drift</strong>, and <strong>leakage current</strong> when selecting values.</li></ul><hr><h3 id="2-3-Coupling-AC-Blocking"><a href="#2-3-Coupling-AC-Blocking" class="headerlink" title="2.3 Coupling / AC Blocking"></a>2.3 Coupling / AC Blocking</h3><p>Used to <strong>pass AC</strong> signals while <strong>blocking DC</strong> bias.</p><ul><li>Common in <strong>audio</strong> and <strong>amplifier</strong> stages.</li><li>Choose capacitors with appropriate <strong>voltage ratings</strong> and <strong>low distortion</strong>.</li></ul><hr><h3 id="2-4-Bypass-Noise-Reduction"><a href="#2-4-Bypass-Noise-Reduction" class="headerlink" title="2.4 Bypass / Noise Reduction"></a>2.4 Bypass / Noise Reduction</h3><p>Used to shunt high-frequency noise and improve signal integrity.</p><ul><li>Small ceramic capacitors (e.g., 0.01 µF, 0.1 µF) are placed close to active components.</li><li>Use <strong>multiple capacitors in parallel</strong> (e.g., 0.1 µF + 10 µF) to cover a wide frequency range.</li></ul><hr><h3 id="2-5-Energy-Storage-Pulsing"><a href="#2-5-Energy-Storage-Pulsing" class="headerlink" title="2.5 Energy Storage / Pulsing"></a>2.5 Energy Storage / Pulsing</h3><p>Used to store and release energy for short bursts.</p><ul><li>Common in <strong>power supplies</strong> and <strong>motor drivers</strong>.</li><li>Use <strong>large electrolytics</strong> or <strong>supercapacitors</strong> with sufficient <strong>voltage</strong> and <strong>ripple current</strong> ratings.</li></ul><hr><h3 id="2-6-Snubber-Damping"><a href="#2-6-Snubber-Damping" class="headerlink" title="2.6 Snubber / Damping"></a>2.6 Snubber / Damping</h3><p>Used to suppress voltage spikes, ringing, and protect switches.</p><ul><li>Typically <strong>RC series</strong> networks.</li><li>Values depend on <strong>transient energy</strong>, <strong>switching frequency</strong>, and <strong>load characteristics</strong>.</li></ul>]]></content>
    
    <summary type="html">
    
      Applied Electronics
    
    </summary>
    
    
      <category term="ece" scheme="https://www.robcholz.com/tags/ece/"/>
    
      <category term="framework" scheme="https://www.robcholz.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>[Foundation] LCEDA</title>
    <link href="https://www.robcholz.com/2025/09/21/lcdea/"/>
    <id>https://www.robcholz.com/2025/09/21/lcdea/</id>
    <published>2025-09-21T21:57:00.000Z</published>
    <updated>2026-01-09T14:54:47.011Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Foundation-LCEDA"><a href="#Foundation-LCEDA" class="headerlink" title="[Foundation] LCEDA"></a>[Foundation] LCEDA</h1><h2 id="Quick-Action"><a href="#Quick-Action" class="headerlink" title="Quick Action"></a>Quick Action</h2><ul><li>Hide Selected Traces: Command+R</li><li>Component Distributed By Region: Shift+P</li><li>Select trace: selected tracing + Shift + W</li></ul><h2 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h2><ol><li>Hide all traces.</li><li>Distribute component by region.</li><li>Hide all designators.</li><li>Import DXF board.</li><li>Start the layout.</li></ol>]]></content>
    
    <summary type="html">
    
      PCB EDA
    
    </summary>
    
    
      <category term="ece" scheme="https://www.robcholz.com/tags/ece/"/>
    
      <category term="framework" scheme="https://www.robcholz.com/tags/framework/"/>
    
      <category term="software" scheme="https://www.robcholz.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>[Foundation]  PCB Layout Guidelines</title>
    <link href="https://www.robcholz.com/2025/09/20/pcb-layout/"/>
    <id>https://www.robcholz.com/2025/09/20/pcb-layout/</id>
    <published>2025-09-20T21:51:00.000Z</published>
    <updated>2026-01-09T14:54:47.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Foundation-PCB-Layout-Guidelines"><a href="#Foundation-PCB-Layout-Guidelines" class="headerlink" title="[Foundation] PCB Layout Guidelines"></a>[Foundation] PCB Layout Guidelines</h1><h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h2><h3 id="Trace-Width-vs-Current-1-oz-Copper"><a href="#Trace-Width-vs-Current-1-oz-Copper" class="headerlink" title="Trace Width vs Current (1 oz Copper)"></a>Trace Width vs Current (1 oz Copper)</h3><table><thead><tr><th>Current</th><th>Typical Trace Width</th><th>Notes</th></tr></thead><tbody><tr><td>GPIO / Low current</td><td>6 mil</td><td>Standard signal width</td></tr><tr><td>0.5 A</td><td>10 mil</td><td>Suitable for LEDs, small sensors</td></tr><tr><td>1 A</td><td>20 mil</td><td></td></tr><tr><td>2 A</td><td>40 mil</td><td></td></tr><tr><td>5 A</td><td>100 mil</td><td></td></tr><tr><td>10 A</td><td>200 mil</td><td>Use solder mask opening and tin coverage</td></tr><tr><td>50 A</td><td>500 mil</td><td></td></tr><tr><td>100 A</td><td>1000 mil</td><td></td></tr><tr><td>200 A</td><td>2000 mil</td><td></td></tr><tr><td>500 A</td><td>5000 mil</td><td>Use ≥4.5 oz copper or bus bars</td></tr></tbody></table><blockquote><p>For high-current paths, widen the trace, increase copper thickness, or apply solder coverage.</p></blockquote><h3 id="Additional-Notes"><a href="#Additional-Notes" class="headerlink" title="Additional Notes"></a>Additional Notes</h3><ul><li>On compact boards, silkscreen reference designators can be omitted.</li><li>Follow the <strong>3W rule</strong> for high-speed signal integrity:<br>→ Distance between traces ≥ 3× trace width.</li></ul><hr><h2 id="2-Layer-Stack-and-Net-Allocation"><a href="#2-Layer-Stack-and-Net-Allocation" class="headerlink" title="2. Layer Stack and Net Allocation"></a>2. Layer Stack and Net Allocation</h2><h3 id="Two-Layer-Board"><a href="#Two-Layer-Board" class="headerlink" title="Two-Layer Board"></a>Two-Layer Board</h3><ul><li>Bottom layer should be as continuous <strong>GND plane</strong> as possible.</li></ul><h3 id="Four-Layer-Board-Options"><a href="#Four-Layer-Board-Options" class="headerlink" title="Four-Layer Board Options"></a>Four-Layer Board Options</h3><table><thead><tr><th>Type</th><th>Stackup</th><th>Characteristics</th></tr></thead><tbody><tr><td><strong>Type 1</strong></td><td>GND / SIG-1 / SIG-2 / PWR</td><td>Simple, but discontinuous impedance</td></tr><tr><td><strong>Type 2</strong></td><td>SIG-1 / PWR / GND / SIG-2</td><td>Good for top-side components or signals</td></tr><tr><td><strong>Type 3</strong></td><td>SIG-1 / GND / PWR / SIG-2</td><td>Good for bottom-side components</td></tr></tbody></table><hr><h2 id="3-Layout-Process"><a href="#3-Layout-Process" class="headerlink" title="3. Layout Process"></a>3. Layout Process</h2><h3 id="EMC-Improvement"><a href="#EMC-Improvement" class="headerlink" title="EMC Improvement"></a>EMC Improvement</h3><h4 id="20H-Rule"><a href="#20H-Rule" class="headerlink" title="20H Rule"></a>20H Rule</h4><ul><li>Shrink the <strong>PWR plane</strong> by:<ul><li><strong>20 mil</strong> → reduces electric field by ~70%</li><li><strong>100 mil</strong> → reduces electric field by ~98%</li></ul></li></ul><h3 id="Recommended-Workflow"><a href="#Recommended-Workflow" class="headerlink" title="Recommended Workflow"></a>Recommended Workflow</h3><ol><li>Place mechanically constrained components first (USB, connectors, mounting holes).</li><li>Plan functional regions: <strong>power</strong>, <strong>digital</strong>, <strong>analog</strong>.</li><li>Route critical or high-speed signals first.</li><li>Add <strong>fanout vias</strong> for low-current power nets.</li><li>Complete all routing.</li><li>Optimize critical traces (short, direct, orthogonal).</li><li>Add <strong>teardrops</strong> and <strong>copper pour</strong>.</li><li>Refine and balance copper planes.</li><li>Run <strong>DRC checks</strong>, verify silkscreen and text orientation.</li><li>Export <strong>Gerber</strong>, <strong>Pick &amp; Place</strong>, and <strong>BOM</strong> files.</li></ol><hr><h2 id="4-Component-Placement-and-Routing"><a href="#4-Component-Placement-and-Routing" class="headerlink" title="4. Component Placement and Routing"></a>4. Component Placement and Routing</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><ul><li>Align designators consistently (e.g., all facing same direction).</li></ul><hr><h3 id="Quartz-Crystal"><a href="#Quartz-Crystal" class="headerlink" title="Quartz Crystal"></a>Quartz Crystal</h3><ul><li>Guard crystal traces with a <strong>10 mil GND ring</strong>.</li><li>Do <strong>not</strong> route as differential pairs.</li><li>Place <strong>as close as possible</strong> to MCU pins.</li><li>Maintain a <strong>solid GND plane</strong> beneath.</li></ul><hr><h3 id="USB-2-0-Interface"><a href="#USB-2-0-Interface" class="headerlink" title="USB 2.0 Interface"></a>USB 2.0 Interface</h3><ul><li>D+/D− are <strong>differential pairs</strong> (~90 Ω differential impedance).</li><li>No copper pour or vias underneath pair.</li><li>Add <strong>bidirectional TVS diode</strong> across D+/D−.</li><li>Add <strong>unidirectional TVS diode</strong> across VBUS and GND.</li><li>Ensure trace widths and planes handle expected <strong>VBUS current</strong>.</li></ul><hr><h3 id="Ground-Domains"><a href="#Ground-Domains" class="headerlink" title="Ground Domains"></a>Ground Domains</h3><ul><li>Separate <strong>AGND</strong>, <strong>DGND</strong>, and <strong>PGND</strong> to minimize interference.</li><li>Connect via:<ul><li>Single point (star ground), or</li><li>Capacitive coupling between domains.</li></ul></li></ul><table><thead><tr><th>Domain</th><th>Recommendation</th></tr></thead><tbody><tr><td><strong>AGND</strong></td><td>Close to analog reference voltage, filters, and amplifiers</td></tr><tr><td><strong>DGND</strong></td><td>Near digital ICs and loads</td></tr><tr><td><strong>PGND</strong></td><td>For high-current or power circuits; connect to star point or via capacitor</td></tr></tbody></table><hr><h3 id="DC-DC-Converter"><a href="#DC-DC-Converter" class="headerlink" title="DC-DC Converter"></a>DC-DC Converter</h3><ul><li>Keep <strong>SW</strong> and <strong>FB</strong> traces as short as possible.</li><li>Isolate inductor from analog and high-speed regions.</li><li>Surround with <strong>GND via fence</strong> to confine EMI.</li><li>Place input/output capacitors <strong>close to pins</strong> — from bulk → ceramic.</li><li>Check chip’s <strong>thermal resistance (°C/W)</strong> and ensure adequate copper area or vias for heat dissipation.</li></ul><hr><h3 id="SDRAM-Design"><a href="#SDRAM-Design" class="headerlink" title="SDRAM Design"></a>SDRAM Design</h3><h4 id="Single-SDRAM"><a href="#Single-SDRAM" class="headerlink" title="Single SDRAM"></a>Single SDRAM</h4><ul><li>Point-to-point routing.</li><li>Place close to MCU/BGA (600–800 mil without resistors; 800–1000 mil with).</li><li>Decoupling capacitors must be <strong>adjacent to power pins</strong>.</li></ul><h4 id="Dual-SDRAM"><a href="#Dual-SDRAM" class="headerlink" title="Dual SDRAM"></a>Dual SDRAM</h4><ul><li>Place <strong>symmetrically</strong> relative to CPU.</li><li>Prefer both on the same layer if space allows; otherwise, top/bottom mirrored.</li><li>Maintain same routing length as single SDRAM layout.</li></ul><h4 id="Routing-Notes"><a href="#Routing-Notes" class="headerlink" title="Routing Notes"></a>Routing Notes</h4><ul><li>Target impedance ≈ <strong>50 Ω</strong>.</li><li>Keep each 9-bit group (D0–D7 + LDQM, D8–D15 + HDQM) on one layer.</li><li>Maintain <strong>≥3W spacing</strong> or <strong>20 mil</strong> between data, address, and clock lines.</li><li>Add GND guard traces (15–30 mil) where possible.</li><li>Length-match tolerances:<ul><li>Data lines: ±50 mil</li><li>Addr/Ctrl/Clock: ±100 mil</li></ul></li></ul><hr><h3 id="TF-MicroSD-Card"><a href="#TF-MicroSD-Card" class="headerlink" title="TF (MicroSD) Card"></a>TF (MicroSD) Card</h3><table><thead><tr><th>Speed</th><th>Impedance Requirement</th></tr></thead><tbody><tr><td>≤ 25 MHz</td><td>~50 Ω single-ended</td></tr><tr><td>&gt; 25 MHz</td><td>~95 Ω differential</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      PCB Layout Guidelines
    
    </summary>
    
    
      <category term="ece" scheme="https://www.robcholz.com/tags/ece/"/>
    
      <category term="framework" scheme="https://www.robcholz.com/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>[Foundation] Setup CLion with STM32CubeMX project for STM32 Development on macOS</title>
    <link href="https://www.robcholz.com/2023/01/22/clion-dev-macos/"/>
    <id>https://www.robcholz.com/2023/01/22/clion-dev-macos/</id>
    <published>2023-01-22T03:52:00.000Z</published>
    <updated>2026-01-09T14:54:46.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Setup-CLion-with-STM32CubeMX-project-for-STM32-Development-on-macOS"><a href="#Setup-CLion-with-STM32CubeMX-project-for-STM32-Development-on-macOS" class="headerlink" title="Setup CLion with STM32CubeMX project for STM32 Development on macOS"></a>Setup CLion with STM32CubeMX project for STM32 Development on macOS</h1><p>Keil is very easy to handle for embedded development but might not have some functionalities such as code completion and inlay hint. This would trouble you especially when you want to conduct a big project.</p><p>IDEs by Jetbrains like Intellij and Pycharm are very popular in the market. They have many advantages including charming UIs, good usability, safe refactoring. Doubtlessly, their IDEs could greatly assist your coding works. CLion is a cross-platform IDE for C/C++ development by Jetbrains, and I will guide you to setup a basic development environment for STM32 with CLion in this tutorial.</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><h3 id="Software"><a href="#Software" class="headerlink" title="Software"></a>Software</h3><ul><li>A computer with macOS(for sure)</li><li>CLion</li><li>STM32CubeMX</li><li>Homebrew</li></ul><h3 id="Hardware"><a href="#Hardware" class="headerlink" title="Hardware"></a>Hardware</h3><ul><li>STM32 MCU</li><li>ST-Link/J-Link</li></ul><h2 id="Installations"><a href="#Installations" class="headerlink" title="Installations"></a>Installations</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><h4 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a><a href="https://www.jetbrains.com/clion/download/#section=mac" target="_blank" rel="noopener">CLion</a></h4><blockquote><p>The version should be higher than 2019.2.</p></blockquote><h4 id="STM32CubeMX"><a href="#STM32CubeMX" class="headerlink" title="STM32CubeMX"></a><a href="https://www.st.com/en/development-tools/stm32cubemx.html#get-software" target="_blank" rel="noopener">STM32CubeMX</a></h4><blockquote><p>Downloading requires email verification.</p></blockquote><p align="middle">  <img src="/2023/01/22/clion-dev-macos/open_package.png" style="width:500px" alt="open"></p><ul><li>After you unzip the downloaded file, right-click the STM32CubeMX package and click <code>Show Package Contents</code> and right click to open the executable file inside the package.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/malware_issue.png" style="width:500px" alt="open"></p><ul><li>There will be an error window popped up. Click <code>Cancel</code>.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/privacy_setting.png" title="width=500"></p><ul><li>Open <code>Security &amp; Privacy</code> in <code>System Preferences</code> and click <code>Allow Anyway</code>.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/open_cubemx.png" title="width=500"></p><ul><li>Open STM32CubeMX executable file again in the package and click <code>Open</code>.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/installation_wizard.png" title="width=500"></p><ul><li>Install STM32CubeMX.</li></ul><h4 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a></h4><blockquote><p>Validate the installation <code>brew -v</code>.</p></blockquote><p>You should have installed these tools above before you continue the next step.</p><h4 id="ARM-Toolchain"><a href="#ARM-Toolchain" class="headerlink" title="ARM Toolchain"></a>ARM Toolchain</h4><ul><li>Run <code>brew tap ArmMbed/homebrew-formulae</code> and <code>brew install arm-none-eabi-gcc</code> in the terminal.</li></ul><blockquote><p>Validate the installation: <code>arm-none-eabi-gcc -v</code>.</p></blockquote><h4 id="OpenOCD"><a href="#OpenOCD" class="headerlink" title="OpenOCD"></a>OpenOCD</h4><p><code>brew install open-ocd</code></p><blockquote><p>Validate the installation: <code>openocd -v</code>.</p></blockquote><h2 id="CLion-Configurations"><a href="#CLion-Configurations" class="headerlink" title="CLion Configurations"></a>CLion Configurations</h2><h3 id="OpenOCD-amp-STM32CubeMX-Paths"><a href="#OpenOCD-amp-STM32CubeMX-Paths" class="headerlink" title="OpenOCD &amp; STM32CubeMX Paths"></a>OpenOCD &amp; STM32CubeMX Paths</h3><p align="middle">  <img src="/2023/01/22/clion-dev-macos/embedded_dev_tools_set.png" title="width=500"></p><ul><li>Generally, both of your OpenOCD and CubeMX locations should be as same as me. Remember to test your paths by clicking <code>Test</code>.</li></ul><h3 id="Toolchains"><a href="#Toolchains" class="headerlink" title="Toolchains"></a>Toolchains</h3><p align="middle">  <img src="/2023/01/22/clion-dev-macos/toolchains.png" title="width=500"></p><ul><li>Set build tools, C/C++ compilers and debuggers. You should use <code>Bundled GDB</code> or like me, manually set another GDB path for <code>Debugger</code> option.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/new_project.png" title="width=500"></p><ul><li>Create a new <code>STM32CubeMX</code> project.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/select_board_type.png" title="width=500"></p><ul><li>Here, you can either click <code>Use</code> to choose a board type or click <code>Skip</code> to choose one later.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/open_with_cubemx.png" title="width=500"></p><ul><li>Click <code>Open with STM32CubeMX</code> to open the application.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/mcu_before.png" title="width=500"></p><ul><li>The default MCU is <code>STM32F030F4Px</code>.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/mcu_after.png" title="width=500"></p><ul><li>You can use STM32CubeMX like what you do everyday.</li></ul><p align="middle">  <img src="/2023/01/22/clion-dev-macos/ide_selection.png" title="width=500"></p><blockquote><ul><li>You have to select <code>STM32CubeIDe</code> in <code>Toolchain / IDE</code> setting, and the <code>Project Name</code> should be kept as same as the project name in CLion.</li></ul></blockquote><p align="middle">  <img src="/2023/01/22/clion-dev-macos/edit_config.png" title="width=500"></p><ul><li>After you generate code and overwrite the old project files, click <code>Assist</code> and choose a board type in <code>Run/Debug Configurations</code>.</li></ul><blockquote><ul><li>You also need to edit the board config file in accordance to the version of your ST-Link.</li></ul></blockquote><p>Congrats! You can now build, upload, and debug in CLion.</p>]]></content>
    
    <summary type="html">
    
      IDE Setup
    
    </summary>
    
    
      <category term="ece" scheme="https://www.robcholz.com/tags/ece/"/>
    
      <category term="framework" scheme="https://www.robcholz.com/tags/framework/"/>
    
      <category term="software" scheme="https://www.robcholz.com/tags/software/"/>
    
  </entry>
  
  <entry>
    <title>This blog has been established</title>
    <link href="https://www.robcholz.com/2022/09/25/blog-post-title-from-file-name/"/>
    <id>https://www.robcholz.com/2022/09/25/blog-post-title-from-file-name/</id>
    <published>2022-09-25T06:55:10.000Z</published>
    <updated>2026-01-09T14:54:46.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="This-blog-has-been-established"><a href="#This-blog-has-been-established" class="headerlink" title="This blog has been established"></a>This blog has been established</h2><p>Blog establishment</p><hr>]]></content>
    
    <summary type="html">
    
      Blog establishment
    
    </summary>
    
    
  </entry>
  
</feed>
